Imports System.Reflection

Imports QB.CodeAnalysis.Text

Namespace Global.QB.CodeAnalysis.Syntax

  Public MustInherit Class SyntaxNode

    Friend Sub New(tree As SyntaxTree, Optional language As String = Nothing)
      SyntaxTree = tree
      Me.Language = language
    End Sub

    ''' <summary>
    ''' Returns SyntaxTree that owns the node.
    ''' </summary>
    ''' <returns></returns>
    Public ReadOnly Property SyntaxTree As SyntaxTree

    MustOverride ReadOnly Property Kind As SyntaxKind

    ''' <summary>
    ''' Determines whether this node or any sub node, token or trivia has annotations.
    ''' </summary>
    ''' <returns></returns>
    Public ReadOnly Property ContainsAnnotations As Boolean
    ''' <summary>
    ''' Determines whether this node or any of its descendant nodes, tokens or trivia have any diagnostics on them.
    ''' </summary>
    ''' <returns></returns>
    Public ReadOnly Property ContainsDiagnostics As Boolean
    ''' <summary>
    ''' Determines whether this node has any descendant preprocessor directives.
    ''' </summary>
    ''' <returns></returns>
    Public ReadOnly Property ContainsDirectives As Boolean
    ''' <summary>
    ''' Determines whether this node has any descendant skipped text.
    ''' </summary>
    ''' <returns></returns>
    Public ReadOnly Property ContainsSkippedText As Boolean
    ''' <summary>
    ''' Determines whether this node has any leading trivia.
    ''' </summary>
    ''' <returns></returns>
    Public ReadOnly Property HasLeadingTrivia As Boolean
    ''' <summary>
    ''' Determines whether this node has any trailing trivia.
    ''' </summary>
    ''' <returns></returns>
    Public ReadOnly Property HasTrailingTrivia As Boolean
    ''' <summary>
    ''' Determines whether the node represents a language construct that was actually parsed from the source code. Missing nodes are generated by the parser in error scenarios to represent constructs that should have been present in the source code in order to compile successfully but were actually missing.
    ''' </summary>
    ''' <returns></returns>
    Public ReadOnly Property IsMissing As Boolean
    Public ReadOnly Property KindText As String
      Get
        Return $"{Kind}"
      End Get
    End Property
    ''' <summary>
    ''' The language name that this node is syntax of.
    ''' </summary>
    ''' <returns></returns>
    Public ReadOnly Property Language As String
    ''' <summary>
    ''' The node that contains this node in its ChildNodes() collection.
    ''' </summary>
    ''' <returns></returns>
    Public ReadOnly Property Parent As SyntaxNode
    Public ReadOnly Property ParentTrivia As SyntaxTrivia
    ''' <summary>
    ''' An integer representing the language specific kind of this node.
    ''' </summary>
    ''' <returns></returns>
    Public ReadOnly Property RawKind As Integer
      Get
        Return Kind
      End Get
    End Property
    ''' <summary>
    ''' The absolute span of this node in characters, not including its leading and trailing trivia.
    ''' </summary>
    ''' <returns></returns>
    Public Overridable ReadOnly Property Span() As TextSpan
      Get
        If GetChildren.Any Then
          Dim first = GetChildren.First.Span
          Dim last = GetChildren.Last.Span
          Return TextSpan.FromBounds(first.Start, last.End)
        Else
          Return TextSpan.FromBounds(0, 0)
        End If
      End Get
    End Property

    ''' <summary>
    ''' Same as accessing Start on Span.
    ''' </summary>
    ''' <returns></returns>
    Public ReadOnly Property StartSpan As Integer
      Get
        Return GetChildren.First.Span.Start
      End Get
    End Property
    ''' <summary>
    ''' The absolute span of this node in characters, including its leading and trailing trivia.
    ''' </summary>
    ''' <returns></returns>
    Public Overridable ReadOnly Property FullSpan() As TextSpan
      Get
        Try
          Dim first = GetChildren.First
          Dim last = GetChildren.Last
          If first Is Nothing OrElse last Is Nothing Then
            Return TextSpan.FromBounds(0, 0)
          Else
            Return TextSpan.FromBounds(first.FullSpan.Start, last.FullSpan.End)
          End If
        Catch
          Return TextSpan.FromBounds(0, 0)
        End Try
      End Get
    End Property

    Public ReadOnly Property Location As TextLocation
      Get
        Return New TextLocation(SyntaxTree.Text, Span)
      End Get
    End Property

    'Public MustOverride Iterator Function GetChildren() As IEnumerable(Of SyntaxNode)

    Public Iterator Function GetChildren() As IEnumerable(Of SyntaxNode)

      Dim properties = [GetType].GetProperties(BindingFlags.Public Or BindingFlags.Instance)

      For Each prop In properties
        If GetType(SyntaxNode).IsAssignableFrom(prop.PropertyType) Then
          Dim child = TryCast(prop.GetValue(Me), SyntaxNode)
          If child IsNot Nothing Then Yield child
        ElseIf GetType(SeparatedSyntaxList).IsAssignableFrom(prop.PropertyType) Then
          Dim separatedSyntaxList = TryCast(prop.GetValue(Me), SeparatedSyntaxList)
          If separatedSyntaxList IsNot Nothing Then
            For Each child In separatedSyntaxList.GetWithSeparators
              If child IsNot Nothing Then Yield child
            Next
          End If
        ElseIf GetType(IEnumerable(Of SyntaxNode)).IsAssignableFrom(prop.PropertyType) Then
          Dim values = TryCast(prop.GetValue(Me), IEnumerable(Of SyntaxNode))
          For Each child In values
            If child IsNot Nothing Then Yield child
          Next
        End If
      Next

    End Function

    Public Function GetLastToken() As SyntaxToken
      If TypeOf Me Is SyntaxToken Then Return CType(Me, SyntaxToken)
      ' A syntax node should always contain at least 1 token.
      Return GetChildren.Last.GetLastToken
    End Function

    Public Sub WriteTo(writer As System.IO.TextWriter)
      PrettyPrint(writer, Me)
    End Sub

    Public Sub WriteTo2(writer As System.IO.TextWriter)
      PrettyPrint2(writer, Me)
    End Sub

    'Private Shared Sub PrettyPrint(writer As System.IO.TextWriter, node As SyntaxNode, Optional indent As String = "", Optional isLast As Boolean = True)

    '  Dim isToConsole = (writer Is Console.Out)
    '  If node Is Nothing Then Return

    '  Dim marker = If(isLast, "└──", "├──")

    '  If isToConsole Then Console.ForegroundColor = ConsoleColor.DarkGray
    '  Console.Write($"{indent}{marker}")
    '  If isToConsole Then Console.ForegroundColor = If(TypeOf node Is SyntaxToken, ConsoleColor.Blue, ConsoleColor.Cyan)
    '  Console.Write($"{node.Kind}")

    '  If isToConsole Then Console.ResetColor()

    '  Dim t = TryCast(node, SyntaxToken)
    '  If t IsNot Nothing Then Console.Write($" {t.Value}")
    '  Console.WriteLine()

    '  indent += If(isLast, "   ", "│  ")

    '  Dim lastChild = node.GetChildren.LastOrDefault

    '  For Each child In node.GetChildren
    '    PrettyPrint(writer, child, indent, child Is lastChild)
    '  Next

    'End Sub

    Private Shared Sub PrettyPrint(writer As System.IO.TextWriter, node As SyntaxNode, Optional indent As String = "", Optional isLast As Boolean = True)

      Dim isToConsole = writer Is Console.Out
      Dim token = TryCast(node, SyntaxToken)

      If token IsNot Nothing Then
        For Each trivia In token.LeadingTrivia

          If isToConsole Then Console.ForegroundColor = ConsoleColor.DarkGray

          writer.Write(indent)
          writer.Write("├──")

          If isToConsole Then Console.ForegroundColor = ConsoleColor.DarkGreen

          writer.WriteLine($"L: {trivia.Kind} '{trivia.Text}'")

        Next
      End If

      Dim hasTrailingTrivia = token IsNot Nothing AndAlso token.TrailingTrivia.Any
      Dim tokenMarker = If(Not hasTrailingTrivia AndAlso isLast, "└──", "├──")

      If isToConsole Then Console.ForegroundColor = ConsoleColor.DarkGray

      writer.Write(indent)
      writer.Write(tokenMarker)

      If isToConsole Then
        Console.ForegroundColor = If(TypeOf node Is SyntaxToken, ConsoleColor.Blue, ConsoleColor.Cyan)
      End If
      writer.Write($"{node.Kind}")

      If token IsNot Nothing Then
        If node.Kind = SyntaxKind.IdentifierToken Then
          If token.Text Is Nothing Then
            Console.ForegroundColor = ConsoleColor.Red
            writer.Write(" !!SN!!")
            'ElseIf functions.Contains(token.Text?.ToUpper) Then
            '  Console.ForegroundColor = ConsoleColor.Yellow
            '  writer.Write($" '{token.Text}':{token.Span.Length}")
          Else
            Console.ForegroundColor = ConsoleColor.DarkCyan
            writer.Write($" '{token.Text}':{token.Span.Length}")
          End If
        ElseIf token.Value IsNot Nothing Then
          writer.Write($" '{token.Value}':{token.Span.Length}")
        End If
      End If

      If isToConsole Then
        Console.ResetColor()
      End If

      writer.WriteLine()

      If token IsNot Nothing Then
        For Each trivia In token.TrailingTrivia

          Dim isLastTrailingTrivia = trivia Is token.TrailingTrivia.Last
          Dim triviaMarker = If(isLast AndAlso isLastTrailingTrivia, "└──", "├──")

          If isToConsole Then Console.ForegroundColor = ConsoleColor.DarkGray

          writer.Write(indent)
          writer.Write(triviaMarker)

          If isToConsole Then Console.ForegroundColor = ConsoleColor.DarkGreen

          If trivia.Kind = SyntaxKind.LineBreakTrivia Then
            writer.WriteLine($"T: {trivia.Kind}")
          Else
            writer.WriteLine($"T: {trivia.Kind} '{trivia.Text}'")
          End If

        Next
      End If

      indent += If(isLast, "   ", "│  ")

      Dim lastChild = node.GetChildren.LastOrDefault

      For Each child In node.GetChildren
        PrettyPrint(writer, child, indent, child Is lastChild)
      Next

    End Sub

    Private Shared Sub PrettyPrint2(writer As System.IO.TextWriter, node As SyntaxNode, Optional indent As String = "", Optional isLast As Boolean = True)

      Dim functions = {"ABS", "ASC", "ASN", "ATN",
        "CDBL", "CHR$", "CINT", "CLNG", "COS", "CSNG", "CSRLIN", "CVD", "CVDMBF", "CVI", "CVL", "CVS", "CVSMBF",
        "DATE$",
        "EOF", "ERDEV", "ERDEV$", "ERL", "ERR", "EXP",
        "FILEATTR", "FIX", "FRE", "FREEFILE",
        "GFXH", "GFXW", "GPOINT",
        "HEX$",
        "INKEY$", "INP", "INPUT$", "INSTR", "INT", "IOCTL$",
        "LBOUND", "LCASE$", "LEFT$", "LEN", "LOC", "LOF", "LOG", "LPOS", "LTRIM$",
        "MAX", "MID$", "MIN", "MKD$", "MKDMBF$", "MKI$", "MKL$", "MKS$", "MKSMBF$", "MOUSEBTN", "MOUSEX", "MOUSEY", "MSECS",
        "OCT$",
        "PEEK", "PLAY", "PI", "PMAP", "POINT", "POWERTWO", "POS",
        "RGBTOINT", "RIGHT$", "RND", "RTRIM$",
        "SCREEN", "SCRH", "SCRW", "SEEK", "SGN", "SIN", "SPACE$", "SPC", "SQR", "STICK", "STR$", "STRIG", "STRING$",
        "TAB", "TAN", "TAU", "TIME$",
        "UBOUND", "UCASE$",
        "VAL", "VARPTR", "VARPTR$", "VARSEG"}

      Dim isToConsole = writer Is Console.Out
      Dim token = TryCast(node, SyntaxToken)

      If token IsNot Nothing Then 'TypeOf node Is SyntaxToken Then

        For Each trivia In token.LeadingTrivia

          If trivia.Kind = SyntaxKind.LineNumberTrivia Then
            If isToConsole Then Console.ForegroundColor = ConsoleColor.DarkGray
            'writer.WriteLine($"{vbLf}{trivia.Text}:")
            writer.Write(trivia.Text)
          ElseIf trivia.Kind = SyntaxKind.WhiteSpaceTrivia Then
            If isToConsole Then Console.ForegroundColor = ConsoleColor.DarkGray
            writer.Write(New String("·"c, trivia.Text.Length))
          Else
            If isToConsole Then Console.ForegroundColor = ConsoleColor.DarkGray
            writer.Write(trivia.Text)
          End If

        Next

        'Dim hasTrailingTrivia = token IsNot Nothing AndAlso token.TrailingTrivia.Any
        'Dim tokenMarker = If(Not hasTrailingTrivia AndAlso isLast, "└──", "├──")

        If isToConsole Then Console.ForegroundColor = ConsoleColor.DarkGray

        Select Case token.Kind
          Case SyntaxKind.BadToken : Console.ForegroundColor = ConsoleColor.Red
          Case SyntaxKind.Label
            If isToConsole Then Console.ForegroundColor = ConsoleColor.DarkGray
          Case SyntaxKind.IdentifierToken
            If token.Text Is Nothing Then
              Console.ForegroundColor = ConsoleColor.Red
              writer.Write("  !!SN!!  ")
            ElseIf functions.Contains(token.Text?.ToUpper) Then
              Console.ForegroundColor = ConsoleColor.Yellow
            Else
              Console.ForegroundColor = ConsoleColor.DarkCyan
            End If
          Case SyntaxKind.StringToken : Console.ForegroundColor = ConsoleColor.DarkYellow
          Case SyntaxKind.NumberToken : Console.ForegroundColor = ConsoleColor.Blue
          Case SyntaxKind.ColonToken, SyntaxKind.SemicolonToken, SyntaxKind.CommaToken
            Console.ForegroundColor = ConsoleColor.Gray
          Case SyntaxKind.EqualToken, SyntaxKind.GreaterThanEqualToken, SyntaxKind.LessThanEqualToken, SyntaxKind.GreaterThanToken, SyntaxKind.LessThanToken
            Console.ForegroundColor = ConsoleColor.Gray
          Case SyntaxKind.PlusToken, SyntaxKind.MinusToken, SyntaxKind.StarToken, SyntaxKind.SlashToken, SyntaxKind.BackslashToken, SyntaxKind.OpenParenToken, SyntaxKind.CloseParenToken
            Console.ForegroundColor = ConsoleColor.Gray
          Case SyntaxKind.NameExpression
            Console.ForegroundColor = ConsoleColor.Magenta
          Case Else
            Console.ForegroundColor = ConsoleColor.Magenta
        End Select

        'If token.Kind = SyntaxKind.ColonToken Then
        '  writer.Write(vbLf)
        'Else
        writer.Write(token.Text)
        'End If

        For Each trivia In token.TrailingTrivia

          If isToConsole Then
            If trivia.Kind = SyntaxKind.SingleLineCommentTrivia Then
              Console.ForegroundColor = ConsoleColor.DarkGreen
              writer.Write(trivia.Text)
            ElseIf trivia.Kind = SyntaxKind.WhiteSpaceTrivia Then
              If isToConsole Then Console.ForegroundColor = ConsoleColor.DarkGray
              writer.Write("·")
            Else
              Console.ForegroundColor = ConsoleColor.DarkGray
              writer.Write(trivia.Text)
            End If
          Else
            writer.Write(trivia.Text)
          End If


        Next

        If isToConsole Then Console.ResetColor()

      End If

      Dim lastChild = node.GetChildren.LastOrDefault

      For Each child In node.GetChildren
        PrettyPrint2(writer, child, indent, child Is lastChild)
      Next

    End Sub

    Public Overrides Function ToString() As String
      Using writer = New System.IO.StringWriter
        WriteTo(writer)
        Return writer.ToString
      End Using
    End Function

    Public Function ToSource() As String
      Return WriteSyntaxTreeToText(Me)
    End Function

    Private Function WriteSyntaxTreeToText(node As SyntaxNode) As String
      Using writer = New System.IO.StringWriter()
        WriteNodeWithTrivia(writer, node)
        Return writer.ToString()
      End Using
    End Function

    Private Sub WriteNodeWithTrivia(writer As System.IO.TextWriter, node As SyntaxNode)
      If TypeOf node Is SyntaxToken Then
        Dim token = CType(node, SyntaxToken)

        ' Write leading trivia
        For Each trivia In token.LeadingTrivia
          writer.Write(trivia.Text)
        Next

        ' Write token text
        writer.Write(token.Text)

        ' Write trailing trivia
        For Each trivia In token.TrailingTrivia
          writer.Write(trivia.Text)
        Next
      Else
        ' Special handling for statements that need custom formatting
        If TypeOf node Is CommonStatementSyntax Then
          Dim commonStmt = CType(node, CommonStatementSyntax)
          WriteNodeWithTrivia(writer, commonStmt.CommonKeyword)
          If commonStmt.SharedKeyword IsNot Nothing Then
            writer.Write(" ")
            WriteNodeWithTrivia(writer, commonStmt.SharedKeyword)
          End If
          writer.Write(" ")
          For i = 0 To commonStmt.Variables.Length - 1
            WriteNodeWithTrivia(writer, commonStmt.Variables(i))
            If i < commonStmt.Variables.Length - 1 Then
              writer.Write(", ")
            End If
          Next
        Else
          ' For non-token nodes, recursively process children
          For Each child In node.GetChildren()
            WriteNodeWithTrivia(writer, child)
          Next
        End If
      End If
    End Sub

  End Class

  Public MustInherit Class QbSyntaxNode
    Inherits SyntaxNode

    Public Sub New(tree As SyntaxTree)
      MyBase.New(tree, "QBasic")
    End Sub

    'Public MustOverride ReadOnly Property Kind As SyntaxKind

  End Class

End Namespace